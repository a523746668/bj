开闭原则：
1对修改关闭，对扩展开放；
2在程序需要扩展的时候，对于一个类，不要去修改原来的代码，而是通过继承的方式去扩展这个类。
3目的：降低维护风险。

单一职责：每个类应该且只有一个职责；提高可读性；

里式替换原则：
1子类继承父类时，可以实现父类的抽象方法，不要 重写 父类的方法，子类增加自己特有的方法。
2目的：防止继承带来的问题。

依赖倒转原则（Dependency Inversion Principle）
1程序要依赖于抽象接口，不要依赖，于具体实现，针对接口编程。
2目的：利于代码升级。

接口隔离原则（Interface Segregation Principle）
1庞大的接口拆分成更小的和更具体的接口，一个接口只用于一个业务逻辑。
2目的：使功能解耦，高内聚、低耦合。

迪米特原则（Principle of Least Knowledge）
1一个对象应当对其他对象尽可能少的了解。
2目的：自己做自己的事情。

合成复用原则（Composite Reuse Principle）
1使用对象组合，而不是继承来达到复用的目的。
2继承破坏了封装性，父类的任何改变，都可能导致子类出问题。
优先考虑 合成复用，A类和B类的合成使用，而不是B继承A的使用。
目的：少用继承 降低耦合

1单例模式：
优点：内存中只有一个实例，减少开销
缺点：没有接口，不能继承，违背了单一职责原则。
public class Singleton{
    private volatile static Singleton instance;
    private Singleton(){};
    public static Singleton getInstance(){
        if(instance==null){
            sychronized(Singleton.class){
                if(instance==null)
                    instance=new Singleton();
            }
        }
        return instatnce;
    }
}

2工厂模式：解决接口选择问题
优点：想要创建对象，只要知道名字就行，屏蔽了内部实现，只要关心接口；
缺点：增加一个产品的时候，需要增加一个实现类 和 一个工厂

3建造者模式：配置一个复杂对象。
1独立，容易扩展
2如果对象复杂，会有很多建造者类。

4适配器模式：解决两个不兼容接口的桥梁,兼容转换。
1优点：让两个没有关联的类一起运行，提高复用。
2缺点：使用过多，会让系统变的凌乱。

5装饰器模式：用来动态的扩展对象的功能，也是继承关系的的一种替代方案之一。在不使用的继承的方式下，采用装饰设计模式可以扩展一个对象的功能，可以使一个对象变得越来越强大。

6代理模式

7策略模式

8观察者模式（Observer Pattern）
目的：一个对象改变通知其他对象，保证协作。
优点：观察者和被观察者是抽象耦合的，也就是说通过抽象方法，给具体的类通知。
缺点：如果观察者有很多，被观察者发消息，会慢，如果不小心观察者和被观察者有依赖，会循环引用。

